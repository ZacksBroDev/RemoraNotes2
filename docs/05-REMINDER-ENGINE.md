# RemoraNotes - Reminder Engine Specification

## Overview

The reminder engine is the core of RemoraNotes. It:

1. Manages reminder **rules** (templates that define patterns)
2. Generates reminder **instances** (concrete upcoming occurrences)
3. Calculates the **Today Queue** (prioritized daily actions)
4. Handles **recalculation** when interactions are logged

---

## Architecture: Rules vs Instances

### Why Separate?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  REMINDER RULES (Templates)                                                  â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Birthday Rule       â”‚  â”‚ Follow-up Rule      â”‚  â”‚ Custom Rule         â”‚ â”‚
â”‚  â”‚ Contact: John       â”‚  â”‚ Contact: ACME Corp  â”‚  â”‚ Contact: Mom        â”‚ â”‚
â”‚  â”‚ Type: birthday      â”‚  â”‚ Type: follow_up     â”‚  â”‚ Type: custom        â”‚ â”‚
â”‚  â”‚ Fixed: Mar 15       â”‚  â”‚ Interval: 30 days   â”‚  â”‚ Fixed: Dec 25       â”‚ â”‚
â”‚  â”‚ Notify: [0, 7]      â”‚  â”‚ Anchor: last_contactâ”‚  â”‚ Notify: [0, 14, 30] â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚            â”‚                        â”‚                        â”‚              â”‚
â”‚            â–¼                        â–¼                        â–¼              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â”‚ Generate
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  REMINDER INSTANCES (Concrete Occurrences)                                   â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Mar 8, 2026    â”‚ â”‚ Mar 15, 2026   â”‚ â”‚ Jan 15, 2026   â”‚ â”‚ Dec 25, 2026 â”‚ â”‚
â”‚  â”‚ John birthday  â”‚ â”‚ John birthday  â”‚ â”‚ Follow up ACME â”‚ â”‚ Mom - Xmas   â”‚ â”‚
â”‚  â”‚ (7 days before)â”‚ â”‚ (day of)       â”‚ â”‚ (30 days since)â”‚ â”‚ (day of)     â”‚ â”‚
â”‚  â”‚ Status: pendingâ”‚ â”‚ Status: pendingâ”‚ â”‚ Status: pendingâ”‚ â”‚ Status: ...  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  Queryable by: dueDate, status, priority, userId                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Benefits**:

1. **Efficient queries**: "What's due today?" is a simple date query on instances
2. **Snooze/complete affects instance only**, rule remains unchanged
3. **Recalculation is additive**: regenerate future instances without losing history
4. **Audit trail**: completed instances show when user took action

---

## Reminder Types

### 1. Birthday Reminders

**Auto-generated** when contact has birthday date.

```javascript
// Rule creation (automatic)
{
  type: 'birthday',
  contactId: contact._id,
  fixedDate: { month: 3, day: 15 },
  notifyDaysBefore: [0, 7], // Day-of and 7 days before
  priority: 'high',
  isAutoGenerated: true,
}

// Instance generation
function generateBirthdayInstances(rule, year) {
  const instances = [];
  const birthdayDate = createDateFromMonthDay(rule.fixedDate, year);

  for (const daysBefore of rule.notifyDaysBefore) {
    const dueDate = subDays(birthdayDate, daysBefore);

    // Only generate if in future
    if (dueDate > new Date()) {
      instances.push({
        ruleId: rule._id,
        dueDate,
        title: daysBefore === 0
          ? `${contact.name}'s birthday is today! ðŸŽ‚`
          : `${contact.name}'s birthday in ${daysBefore} days`,
        instanceKey: `${rule._id}:${format(dueDate, 'yyyy-MM-dd')}`,
      });
    }
  }

  return instances;
}
```

**Leap Year Handling** (Feb 29):

```javascript
function createDateFromMonthDay({ month, day }, year) {
  // Handle Feb 29 in non-leap years
  if (month === 2 && day === 29 && !isLeapYear(year)) {
    return new Date(year, 1, 28); // Feb 28
  }
  return new Date(year, month - 1, day);
}
```

### 2. Anniversary Reminders

Same structure as birthdays, different default priority.

```javascript
{
  type: 'anniversary',
  contactId: contact._id,
  fixedDate: { month: 6, day: 20 },
  notifyDaysBefore: [0, 7, 30], // More advance notice
  priority: 'medium',
}
```

### 3. Follow-Up Reminders (Interval-Based)

**Key feature**: Recalculates when user logs an interaction.

```javascript
// Rule
{
  type: 'follow_up',
  contactId: contact._id,
  interval: {
    days: 30,
    anchor: 'last_contact', // Dynamic anchor
  },
  priority: 'high',
}

// Instance generation
function generateFollowUpInstance(rule, contact) {
  const anchorDate = getAnchorDate(rule, contact);
  const dueDate = addDays(anchorDate, rule.interval.days);

  // Only generate if in future
  if (dueDate <= new Date()) {
    // Already overdue - due today
    return {
      ruleId: rule._id,
      dueDate: startOfToday(),
      isOverdue: true,
      daysOverdue: differenceInDays(new Date(), dueDate),
    };
  }

  return {
    ruleId: rule._id,
    dueDate,
    isOverdue: false,
    instanceKey: `${rule._id}:${format(dueDate, 'yyyy-MM-dd')}`,
  };
}

function getAnchorDate(rule, contact) {
  switch (rule.interval.anchor) {
    case 'last_contact':
      return contact.lastContactedAt || contact.createdAt;
    case 'rule_creation':
      return rule.createdAt;
    case 'custom_date':
      return rule.interval.customAnchorDate;
  }
}
```

### 4. Holiday Reminders

Pre-defined or custom holidays.

```javascript
// System holidays (shared)
const SYSTEM_HOLIDAYS = {
  'us-christmas': { name: 'Christmas', month: 12, day: 25 },
  'us-thanksgiving': { name: 'Thanksgiving', dynamic: true }, // 4th Thursday Nov
  'us-mothers-day': { name: "Mother's Day", dynamic: true },  // 2nd Sunday May
};

// Rule
{
  type: 'holiday',
  contactId: contact._id, // Optional - may be general
  fixedDate: { month: 12, day: 25 },
  title: 'Send Christmas card to Mom',
  notifyDaysBefore: [14, 7], // Send cards early!
  priority: 'medium',
}
```

### 5. Custom Date Reminders

User-defined one-time or recurring dates.

```javascript
{
  type: 'custom',
  contactId: contact._id,
  title: 'Renew contract with ACME',
  fixedDate: { month: 6, day: 1 },
  notifyDaysBefore: [30, 14, 0],
  priority: 'high',
}
```

---

## Instance Generation Algorithm

### When to Generate

1. **On rule creation**: Generate next N occurrences
2. **Daily recalculation job**: Regenerate for all rules (hourly at :15)
3. **On interaction logged**: Regenerate follow-up instances for that contact
4. **On contact update**: If birthday/anniversary changed

### Generation Logic

```javascript
async function generateInstancesForRule(rule, options = {}) {
  const { horizonDays = 365 } = options;
  const horizonDate = addDays(new Date(), horizonDays);
  const instances = [];

  switch (rule.type) {
    case "birthday":
    case "anniversary":
      // Generate for this year and next year
      const currentYear = new Date().getFullYear();

      for (const year of [currentYear, currentYear + 1]) {
        const occurrenceDate = createDateFromMonthDay(rule.fixedDate, year);

        // Skip if past
        if (occurrenceDate <= new Date()) continue;
        // Skip if beyond horizon
        if (occurrenceDate > horizonDate) continue;

        // Generate instances for each notification day
        for (const daysBefore of rule.notifyDaysBefore) {
          const dueDate = subDays(occurrenceDate, daysBefore);
          if (dueDate > new Date() && dueDate <= horizonDate) {
            instances.push(createInstance(rule, dueDate, { daysBefore }));
          }
        }
      }
      break;

    case "follow_up":
      const contact = await Contact.findById(rule.contactId);
      const instance = generateFollowUpInstance(rule, contact);
      if (instance) instances.push(instance);
      break;

    case "holiday":
    case "custom":
      // Similar to birthday logic
      // ...
      break;
  }

  return instances;
}

function createInstance(rule, dueDate, metadata = {}) {
  return {
    ruleId: rule._id,
    userId: rule.userId,
    contactId: rule.contactId,
    dueDate,
    status: "pending",
    type: rule.type,
    priority: rule.priority,
    title: generateTitle(rule, metadata),
    instanceKey: `${rule._id}:${format(dueDate, "yyyy-MM-dd")}`,
  };
}
```

### Idempotency via instanceKey

```javascript
async function saveInstances(instances) {
  const operations = instances.map((instance) => ({
    updateOne: {
      filter: { instanceKey: instance.instanceKey },
      update: { $setOnInsert: instance },
      upsert: true,
    },
  }));

  await ReminderInstance.bulkWrite(operations, { ordered: false });
}
```

This ensures:

- Same instance isn't created twice
- Completed/snoozed instances aren't overwritten
- Recalculation is safe to run multiple times

---

## Today Queue Algorithm

### Purpose

Present users with a **prioritized, capped list** of what to do today.

### Algorithm

```javascript
async function getTodayQueue(userId) {
  const user = await User.findById(userId);
  const now = new Date();
  const today = startOfDay(now);
  const todayEnd = endOfDay(now);

  // Step 1: Get all pending/overdue reminders
  const candidates = await ReminderInstance.find({
    userId,
    status: "pending",
    $or: [
      { dueDate: { $lte: todayEnd } }, // Due today or before
      { snoozedUntil: { $lte: now } }, // Snooze expired
    ],
  }).populate("contactId");

  // Step 2: Score each candidate
  const scored = candidates.map((instance) => ({
    ...instance.toObject(),
    score: calculateScore(instance, user.mode),
  }));

  // Step 3: Sort by score descending
  scored.sort((a, b) => b.score - a.score);

  // Step 4: Apply tier cap
  const cap = user.plan === "pro" ? 25 : 10;
  const queue = scored.slice(0, cap);
  const overflow = scored.slice(cap);

  return {
    items: queue,
    overflowCount: overflow.length,
    totalDueToday: scored.length,
  };
}
```

### Scoring Algorithm

```javascript
function calculateScore(instance, userMode) {
  let score = 0;

  // 1. Base score by type
  const TYPE_SCORES = {
    birthday: 15,
    anniversary: 12,
    follow_up: 10,
    holiday: 8,
    custom: 8,
  };
  score += TYPE_SCORES[instance.type] || 5;

  // 2. Priority multiplier
  const PRIORITY_MULTIPLIERS = {
    high: 3,
    medium: 2,
    low: 1,
  };
  score *= PRIORITY_MULTIPLIERS[instance.priority] || 1;

  // 3. Contact importance (if available)
  if (instance.contactId?.business?.importance) {
    score *= instance.contactId.business.importance / 5; // Normalize to 0.2-2x
  }

  // 4. Overdue penalty (higher score for more overdue)
  if (instance.isOverdue || instance.dueDate < startOfToday()) {
    const daysOverdue = differenceInDays(new Date(), instance.dueDate);
    score += daysOverdue * 5; // +5 per day overdue
  }

  // 5. Mode-specific adjustments
  if (userMode === "business") {
    // Boost client/lead contacts in business mode
    const contact = instance.contactId;
    if (contact?.tags?.some((t) => ["client", "lead"].includes(t))) {
      score *= 1.5;
    }
  }

  // 6. Snooze penalty (snoozed items slightly deprioritized)
  if (instance.snoozeCount > 0) {
    score *= Math.pow(0.9, instance.snoozeCount); // 10% penalty per snooze
  }

  return Math.round(score);
}
```

### Score Examples

| Reminder                             | Base | Priority  | Importance | Overdue | Mode       | Final |
| ------------------------------------ | ---- | --------- | ---------- | ------- | ---------- | ----- |
| Birthday (high-importance client)    | 15   | Ã—3 (high) | Ã—2 (10/5)  | +0      | Ã—1.5 (biz) | 135   |
| Follow-up (medium lead, 3 days late) | 10   | Ã—2 (med)  | Ã—1 (5/5)   | +15     | Ã—1.5 (biz) | 53    |
| Anniversary (friend, on time)        | 12   | Ã—2 (med)  | Ã—0.6 (3/5) | +0      | Ã—1         | 14    |
| Custom (low priority, snoozed twice) | 8    | Ã—1 (low)  | Ã—1         | +0      | Ã—0.81      | 6     |

---

## Interaction Logging & Recalculation

### When User Logs Interaction

```javascript
async function logInteraction(userId, contactId, interactionData) {
  const session = await mongoose.startSession();

  try {
    await session.withTransaction(async () => {
      // 1. Create interaction record
      const interaction = await Interaction.create(
        [
          {
            userId,
            contactId,
            occurredAt: interactionData.date || new Date(),
            type: interactionData.type,
            notes: interactionData.notes,
          },
        ],
        { session }
      );

      // 2. Update contact's lastContactedAt
      await Contact.updateOne(
        { _id: contactId },
        {
          $set: { lastContactedAt: interactionData.date || new Date() },
          $inc: { interactionCount: 1 },
        },
        { session }
      );

      // 3. Recalculate follow-up reminders for this contact
      await recalculateFollowUps(userId, contactId, session);

      // 4. Audit log
      await AuditLog.create(
        [
          {
            userId,
            category: "reminder",
            action: "INTERACTION_LOGGED",
            metadata: { contactId, interactionType: interactionData.type },
          },
        ],
        { session }
      );
    });
  } finally {
    await session.endSession();
  }
}
```

### Recalculation Logic

```javascript
async function recalculateFollowUps(userId, contactId, session) {
  // Find all active follow-up rules for this contact
  const rules = await ReminderRule.find({
    userId,
    contactId,
    type: "follow_up",
    isActive: true,
  }).session(session);

  const contact = await Contact.findById(contactId).session(session);

  for (const rule of rules) {
    // Delete pending (not completed) instances for this rule
    await ReminderInstance.deleteMany({
      ruleId: rule._id,
      status: "pending",
    }).session(session);

    // Generate new instance based on new lastContactedAt
    const newInstance = generateFollowUpInstance(rule, contact);

    if (newInstance) {
      await ReminderInstance.create([newInstance], { session });
    }
  }
}
```

---

## Reminder Actions

### Complete

```javascript
async function completeReminder(userId, instanceId, note) {
  const instance = await ReminderInstance.findOneAndUpdate(
    { _id: instanceId, userId, status: "pending" },
    {
      status: "completed",
      completedAt: new Date(),
      completedNote: note,
    },
    { new: true }
  );

  if (!instance) {
    throw new NotFoundError("Reminder not found or already completed");
  }

  // If follow-up, also log as interaction
  if (instance.type === "follow_up" && instance.contactId) {
    await logInteraction(userId, instance.contactId, {
      date: new Date(),
      type: "other",
      notes: note,
      reminderInstanceId: instanceId,
    });
  }

  return instance;
}
```

### Snooze

```javascript
const SNOOZE_OPTIONS = {
  "1h": { hours: 1 },
  "3h": { hours: 3 },
  tomorrow: { days: 1 },
  "3d": { days: 3 },
  "1w": { days: 7 },
  custom: null, // User provides date
};

async function snoozeReminder(userId, instanceId, snoozeDuration) {
  let snoozedUntil;

  if (snoozeDuration === "tomorrow") {
    snoozedUntil = startOfDay(addDays(new Date(), 1));
    snoozedUntil.setHours(9, 0, 0, 0); // 9 AM tomorrow
  } else if (SNOOZE_OPTIONS[snoozeDuration]) {
    snoozedUntil = add(new Date(), SNOOZE_OPTIONS[snoozeDuration]);
  } else if (snoozeDuration instanceof Date) {
    snoozedUntil = snoozeDuration;
  } else {
    throw new ValidationError("Invalid snooze duration");
  }

  const instance = await ReminderInstance.findOneAndUpdate(
    { _id: instanceId, userId },
    {
      status: "snoozed",
      snoozedUntil,
      $inc: { snoozeCount: 1 },
    },
    { new: true }
  );

  return instance;
}
```

### Skip

```javascript
async function skipReminder(userId, instanceId) {
  const instance = await ReminderInstance.findOneAndUpdate(
    { _id: instanceId, userId, status: "pending" },
    {
      status: "skipped",
      completedAt: new Date(),
    },
    { new: true }
  );

  return instance;
}
```

### Reschedule

```javascript
async function rescheduleReminder(userId, instanceId, newDate) {
  // Don't modify existing - create new instance
  const existing = await ReminderInstance.findOne({
    _id: instanceId,
    userId,
    status: "pending",
  });

  if (!existing) {
    throw new NotFoundError("Reminder not found");
  }

  // Mark old as skipped
  await ReminderInstance.updateOne({ _id: instanceId }, { status: "skipped" });

  // Create new instance
  const newInstance = await ReminderInstance.create({
    ...existing.toObject(),
    _id: new mongoose.Types.ObjectId(),
    dueDate: newDate,
    instanceKey: `${existing.ruleId}:${format(
      newDate,
      "yyyy-MM-dd"
    )}:rescheduled`,
    status: "pending",
    snoozeCount: 0,
  });

  return newInstance;
}
```

---

## Background Recalculation Job

### Schedule

Runs hourly at :15 (e.g., 8:15, 9:15, 10:15)

### Logic

```javascript
// Lambda handler
export async function handler(event) {
  const jobId = `reminder-recalc:${format(new Date(), "yyyy-MM-dd-HH")}`;

  // Idempotency check
  const existing = await AuditLog.findOne({ idempotencyKey: jobId });
  if (existing) {
    console.log(`Job ${jobId} already processed`);
    return { skipped: true };
  }

  // Write start log
  await AuditLog.create({
    category: "reminder",
    action: "REMINDER_RECALC_START",
    idempotencyKey: jobId,
    timestamp: new Date(),
  });

  let processed = 0;
  let errors = 0;

  // Process in batches
  const cursor = ReminderRule.find({ isActive: true }).cursor();

  for await (const rule of cursor) {
    try {
      const instances = await generateInstancesForRule(rule);
      await saveInstances(instances);
      processed++;
    } catch (error) {
      errors++;
      console.error(`Error processing rule ${rule._id}:`, error.message);
    }
  }

  // Write completion log
  await AuditLog.create({
    category: "reminder",
    action: "REMINDER_RECALC_COMPLETE",
    metadata: { processed, errors },
    timestamp: new Date(),
  });

  return { processed, errors };
}
```

---

## Default Presets by Mode

### Business Mode Defaults

```javascript
const BUSINESS_PRESETS = {
  defaultFollowUpDays: {
    client: 30,
    lead: 14,
    prospect: 7,
    vendor: 90,
    partner: 60,
  },
  birthdayNotifyDaysBefore: [0, 3],
  defaultPriority: "medium",
  defaultTags: ["client", "lead", "prospect", "vendor", "partner"],
};
```

### Personal Mode Defaults

```javascript
const PERSONAL_PRESETS = {
  defaultFollowUpDays: {
    friend: 60,
    family: 90,
    acquaintance: 180,
  },
  birthdayNotifyDaysBefore: [0, 7, 30],
  anniversaryNotifyDaysBefore: [0, 7, 30],
  defaultPriority: "medium",
  defaultTags: ["friend", "family", "acquaintance"],
};
```

### Both Mode

Combines presets, with business taking precedence for contacts with business tags.

---

## Performance Considerations

1. **Denormalization**: contactName, type, priority stored on instances to avoid joins
2. **Indexes**: Compound indexes on (userId, status, dueDate) for Today Queue
3. **Batch processing**: Recalculation uses cursor iteration, not loading all rules
4. **Idempotency keys**: Allow safe job retries without duplicates
5. **Horizon limits**: Only generate instances for next 365 days
